# Copyright 2024 Santiago Mattiauda
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0

# Plugin Information
plugin.name=Structured Coroutines
plugin.description=Enforces structured concurrency best practices for Kotlin Coroutines

# Inspection Group
inspection.group.name=Coroutines

# Inspection Display Names
inspection.global.scope.display.name=GlobalScope usage
inspection.main.dispatcher.display.name=Main dispatcher misuse
inspection.scope.reuse.display.name=Scope reuse after cancel
inspection.run.blocking.display.name=runBlocking in suspend function
inspection.unstructured.launch.display.name=Unstructured coroutine launch
inspection.async.without.await.display.name=async without await
inspection.inline.scope.display.name=Inline CoroutineScope creation
inspection.job.in.builder.display.name=Job in builder context
inspection.suspend.in.finally.display.name=Suspend call in finally block
inspection.cancellation.swallowed.display.name=CancellationException swallowed
inspection.dispatchers.unconfined.display.name=Dispatchers.Unconfined usage

# Inspection Descriptions
inspection.global.scope.description=GlobalScope bypasses structured concurrency and can lead to resource leaks. Use framework scopes (viewModelScope, lifecycleScope), @StructuredScope annotated scopes, or structured builders (coroutineScope, supervisorScope).
inspection.main.dispatcher.description=Blocking code on Dispatchers.Main can cause ANRs on Android or freeze the UI. Use Dispatchers.IO for blocking operations.
inspection.scope.reuse.description=Cancelling a CoroutineScope and then trying to launch more coroutines in that same scope doesn't work. Use cancelChildren() instead of cancel() if you need to reuse the scope.
inspection.run.blocking.description=runBlocking blocks the thread and defeats the purpose of coroutines. Use runBlocking only at top level (main, test functions).
inspection.unstructured.launch.description=Coroutine launched without a structured scope. Use framework scopes, @StructuredScope annotated scopes, or structured builders.
inspection.async.without.await.description=async creates a Deferred that should be awaited. If you don't need the result, use launch instead.
inspection.inline.scope.description=Creating inline CoroutineScope bypasses structured concurrency. Use a managed scope with proper lifecycle.
inspection.job.in.builder.description=Using Job() or SupervisorJob() in coroutine builders breaks structured concurrency. Use supervisorScope { } for independent child failures.
inspection.suspend.in.finally.description=Suspend calls in finally blocks may not complete if the coroutine is cancelled. Wrap with withContext(NonCancellable) { }.
inspection.cancellation.swallowed.description=Catching Exception without rethrowing CancellationException breaks coroutine cancellation. Handle CancellationException separately.
inspection.dispatchers.unconfined.description=Dispatchers.Unconfined can lead to unpredictable execution and should be avoided except in specific testing scenarios.

# Quick Fix Names
quickfix.replace.global.scope=Replace with {0}
quickfix.replace.global.scope.viewmodel=Replace GlobalScope with viewModelScope
quickfix.replace.global.scope.lifecycle=Replace GlobalScope with lifecycleScope
quickfix.replace.global.scope.coroutinescope=Replace GlobalScope with coroutineScope { }
quickfix.wrap.with.io.dispatcher=Wrap with withContext(Dispatchers.IO)
quickfix.replace.cancel.with.cancel.children=Replace cancel() with cancelChildren()
quickfix.remove.run.blocking=Remove runBlocking
quickfix.add.await=Add .await()
quickfix.convert.async.to.launch=Convert async to launch
quickfix.wrap.with.non.cancellable=Wrap with withContext(NonCancellable)
quickfix.add.cancellation.exception.catch=Add CancellationException catch clause
quickfix.replace.job.with.supervisor.scope=Replace with supervisorScope { }

# Intention Names
intention.category=Structured Coroutines
intention.migrate.to.viewmodel.scope=Migrate to viewModelScope
intention.migrate.to.viewmodel.scope.description=Migrate coroutine scope to viewModelScope for ViewModel classes
intention.migrate.to.lifecycle.scope=Migrate to lifecycleScope
intention.migrate.to.lifecycle.scope.description=Migrate coroutine scope to lifecycleScope for LifecycleOwner classes
intention.wrap.with.coroutine.scope=Wrap with coroutineScope { }
intention.wrap.with.coroutine.scope.description=Wrap suspend function content with coroutineScope builder
intention.convert.launch.to.async=Convert launch to async
intention.convert.launch.to.async.description=Convert launch call to async for returning a Deferred
intention.extract.suspend.function=Extract suspend function
intention.extract.suspend.function.description=Extract coroutine lambda body to a suspend function

# Gutter Icon Tooltips
gutter.scope.viewmodel=viewModelScope - ViewModel lifecycle
gutter.scope.lifecycle=lifecycleScope - Lifecycle lifecycle
gutter.scope.global=GlobalScope - No lifecycle (danger!)
gutter.scope.coroutine=coroutineScope - Structured scope
gutter.scope.supervisor=supervisorScope - Supervisor scope
gutter.scope.custom=Custom CoroutineScope
gutter.dispatcher.main=Dispatchers.Main - UI thread
gutter.dispatcher.io=Dispatchers.IO - I/O operations
gutter.dispatcher.default=Dispatchers.Default - CPU-intensive
gutter.dispatcher.unconfined=Dispatchers.Unconfined - Unconfined (warning)

# Error Messages
error.global.scope.usage=GlobalScope.{0} bypasses structured concurrency
error.main.dispatcher.blocking=Blocking call on Dispatchers.Main can cause ANR
error.scope.reuse.after.cancel=Scope ''{0}'' is cancelled and then reused
error.run.blocking.in.suspend=runBlocking in suspend function blocks the thread
error.unstructured.launch=Coroutine launched without structured scope
error.async.without.await=async result is never awaited
error.inline.scope=CoroutineScope(...).{0} bypasses structured concurrency
error.job.in.builder={0}() in coroutine builder breaks structured concurrency
error.suspend.in.finally=Suspend call in finally may not complete if cancelled
error.cancellation.swallowed=catch(Exception) may swallow CancellationException
error.dispatchers.unconfined=Dispatchers.Unconfined should be avoided in production
