# Copyright 2026 Santiago Mattiauda
# Plugin IntelliJ - textos para el usuario (espa\u00f1ol)

# Plugin Information
plugin.name=Structured Coroutines
plugin.description=Aplica buenas pr\u00e1cticas de concurrencia estructurada para Kotlin Coroutines

# Inspection Group
inspection.group.name=Coroutines

# Inspection Display Names
inspection.global.scope.display.name=Uso de GlobalScope
inspection.main.dispatcher.display.name=Uso incorrecto del dispatcher Main
inspection.scope.reuse.display.name=Reutilizaci\u00f3n de scope tras cancelar
inspection.run.blocking.display.name=runBlocking en funci\u00f3n suspend
inspection.unstructured.launch.display.name=Launch de corrutina no estructurado
inspection.async.without.await.display.name=async sin await
inspection.inline.scope.display.name=Creaci\u00f3n inline de CoroutineScope
inspection.job.in.builder.display.name=Job en contexto de builder
inspection.suspend.in.finally.display.name=Llamada suspend en bloque finally
inspection.cancellation.swallowed.display.name=CancellationException tragada
inspection.cancellation.subclass.display.name=Subclase de CancellationException (error de dominio)
inspection.dispatchers.unconfined.display.name=Uso de Dispatchers.Unconfined
inspection.loop.without.yield.display.name=Bucle sin punto de cooperaci\u00f3n

# Inspection Descriptions (c\u00f3digo de regla + enlace Learn more)
inspection.doc.base.url=https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md

inspection.global.scope.description=<html>GlobalScope evita la concurrencia estructurada y puede provocar fugas de recursos. Use scopes de framework (viewModelScope, lifecycleScope), scopes anotados con @StructuredScope o builders estructurados (coroutineScope, supervisorScope).<br/><br/><b>SCOPE_001</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#11-scope_001--using-globalscope-in-production-code">M\u00e1s informaci\u00f3n</a></html>
inspection.main.dispatcher.description=<html>El c\u00f3digo bloqueante en Dispatchers.Main puede causar ANR en Android o bloquear la UI. Use Dispatchers.IO para operaciones bloqueantes.<br/><br/><b>DISPATCH_001</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#31-dispatch_001--mixing-blocking-code-with-wrong-dispatchers">M\u00e1s informaci\u00f3n</a></html>
inspection.scope.reuse.description=<html>Cancelar un CoroutineScope y luego lanzar m\u00e1s corrutinas en ese scope no funciona. Use cancelChildren() en lugar de cancel() si necesita reutilizar el scope.<br/><br/><b>CANCEL_005</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#45-cancel_005--reusing-a-cancelled-coroutinescope">M\u00e1s informaci\u00f3n</a></html>
inspection.run.blocking.description=<html>runBlocking bloquea el hilo y va contra el prop\u00f3sito de las corrutinas. Use runBlocking solo en el nivel superior (main, funciones de test).<br/><br/><b>RUNBLOCK_002</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#22-runblock_002--using-runblocking-inside-suspend-functions">M\u00e1s informaci\u00f3n</a></html>
inspection.unstructured.launch.description=<html>Corrutina lanzada sin un scope estructurado. Use scopes de framework, @StructuredScope o builders estructurados.<br/><br/><b>SCOPE_003</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#13-scope_003--breaking-structured-concurrency">M\u00e1s informaci\u00f3n</a></html>
inspection.async.without.await.description=<html>async crea un Deferred que debe esperarse. Si no necesita el resultado, use launch.<br/><br/><b>SCOPE_002</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#12-scope_002--using-async-without-calling-await">M\u00e1s informaci\u00f3n</a></html>
inspection.inline.scope.description=<html>Crear CoroutineScope inline evita la concurrencia estructurada. Use un scope gestionado con ciclo de vida adecuado.<br/><br/><b>SCOPE_003</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#13-scope_003--breaking-structured-concurrency">M\u00e1s informaci\u00f3n</a></html>
inspection.job.in.builder.description=<html>Usar Job() o SupervisorJob() en builders de corrutinas rompe la concurrencia estructurada. Use supervisorScope { } para fallos independientes de hijos.<br/><br/><b>DISPATCH_004</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#34-dispatch_004--passing-job-directly-as-context-to-builders">M\u00e1s informaci\u00f3n</a></html>
inspection.suspend.in.finally.description=<html>Las llamadas suspend en bloques finally pueden no completarse si la corrutina se cancela. Envuelva con withContext(NonCancellable) { }.<br/><br/><b>CANCEL_004</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#44-cancel_004--suspendable-cleanup-without-noncancellable">M\u00e1s informaci\u00f3n</a></html>
inspection.cancellation.swallowed.description=<html>Capturar Exception sin relanzar CancellationException rompe la cancelaci\u00f3n de corrutinas. Maneje CancellationException por separado.<br/><br/><b>CANCEL_003</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#43-cancel_003--swallowing-cancellationexception">M\u00e1s informaci\u00f3n</a></html>
inspection.cancellation.subclass.description=<html>No est\u00e1 permitido extender CancellationException para errores de dominio. CancellationException tiene sem\u00e1ntica especial en corrutinas. Use Exception o RuntimeException para errores de dominio.<br/><br/><b>EXCEPT_002</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#52-except_002--extending-cancellationexception-for-domain-errors">M\u00e1s informaci\u00f3n</a></html>
inspection.dispatchers.unconfined.description=<html>Dispatchers.Unconfined puede dar ejecuci\u00f3n impredecible; ev\u00edtelo salvo en pruebas concretas.<br/><br/><b>DISPATCH_003</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#33-dispatch_003--abusing-dispatchersunconfined">M\u00e1s informaci\u00f3n</a></html>
inspection.loop.without.yield.description=<html>Bucles en funciones suspend sin puntos de cooperaci\u00f3n no pueden cancelarse hasta que terminen. A\u00f1ada ensureActive(), yield() o delay() dentro del bucle.<br/><br/><b>CANCEL_001</b>. <a href="https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#41-cancel_001--ignoring-cancellation-in-intensive-loops">M\u00e1s informaci\u00f3n</a></html>

# Quick Fix Names
quickfix.replace.global.scope=Reemplazar con {0}
quickfix.replace.global.scope.viewmodel=Reemplazar GlobalScope por viewModelScope
quickfix.replace.global.scope.lifecycle=Reemplazar GlobalScope por lifecycleScope
quickfix.replace.global.scope.coroutinescope=Reemplazar GlobalScope por coroutineScope { }
quickfix.wrap.with.io.dispatcher=Envolver con withContext(Dispatchers.IO)
quickfix.replace.cancel.with.cancel.children=Reemplazar cancel() por cancelChildren()
quickfix.remove.run.blocking=Eliminar runBlocking
quickfix.add.await=A\u00f1adir .await()
quickfix.convert.async.to.launch=Convertir async a launch
quickfix.wrap.with.non.cancellable=Envolver con withContext(NonCancellable)
quickfix.add.cancellation.exception.catch=A\u00f1adir cl\u00e1usula catch de CancellationException
quickfix.replace.job.with.supervisor.scope=Reemplazar por supervisorScope { }
quickfix.add.ensure.active.in.loop=A\u00f1adir ensureActive() en el bucle

# Intention Names
intention.category=Structured Coroutines
intention.migrate.to.viewmodel.scope=Migrar a viewModelScope
intention.migrate.to.viewmodel.scope.description=Migrar el scope de corrutina a viewModelScope para clases ViewModel
intention.migrate.to.lifecycle.scope=Migrar a lifecycleScope
intention.migrate.to.lifecycle.scope.description=Migrar el scope de corrutina a lifecycleScope para LifecycleOwner
intention.wrap.with.coroutine.scope=Envolver con coroutineScope { }
intention.wrap.with.coroutine.scope.description=Envolver el contenido de la funci\u00f3n suspend con el builder coroutineScope
intention.convert.launch.to.async=Convertir launch a async
intention.convert.launch.to.async.description=Convertir la llamada launch a async para devolver un Deferred
intention.extract.suspend.function=Extraer funci\u00f3n suspend
intention.extract.suspend.function.description=Extraer el cuerpo de la lambda de corrutina a una funci\u00f3n suspend

# Gutter Icon Tooltips
gutter.scope.viewmodel=viewModelScope - ciclo de vida ViewModel
gutter.scope.lifecycle=lifecycleScope - ciclo de vida
gutter.scope.global=GlobalScope - sin ciclo de vida (\u00a1peligro!)
gutter.scope.coroutine=coroutineScope - scope estructurado
gutter.scope.supervisor=supervisorScope - scope supervisor
gutter.scope.custom=CoroutineScope personalizado
gutter.dispatcher.main=Dispatchers.Main - hilo UI
gutter.dispatcher.io=Dispatchers.IO - operaciones I/O
gutter.dispatcher.default=Dispatchers.Default - uso intensivo de CPU
gutter.dispatcher.unconfined=Dispatchers.Unconfined - sin confinar (advertencia)

# Error Messages (incluir enlace para que aparezca en el tooltip / vista de problemas)
error.global.scope.usage=[SCOPE_001] GlobalScope.{0} evita la concurrencia estructurada. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#11-scope_001--using-globalscope-in-production-code
error.main.dispatcher.blocking=[DISPATCH_001] Llamada bloqueante en Dispatchers.Main puede causar ANR. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#31-dispatch_001--mixing-blocking-code-with-wrong-dispatchers
error.scope.reuse.after.cancel=[CANCEL_005] El scope ''{0}'' est\u00e1 cancelado y se reutiliza. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#45-cancel_005--reusing-a-cancelled-coroutinescope
error.run.blocking.in.suspend=[RUNBLOCK_002] runBlocking en funci\u00f3n suspend bloquea el hilo. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#22-runblock_002--using-runblocking-inside-suspend-functions
error.unstructured.launch=[SCOPE_003] Corrutina lanzada sin scope estructurado. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#13-scope_003--breaking-structured-concurrency
error.async.without.await=[SCOPE_002] El resultado de async no se espera nunca. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#12-scope_002--using-async-without-calling-await
error.inline.scope=[SCOPE_003] CoroutineScope(...).{0} evita la concurrencia estructurada. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#13-scope_003--breaking-structured-concurrency
error.job.in.builder=[DISPATCH_004] {0}() en builder de corrutina rompe la concurrencia estructurada. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#34-dispatch_004--passing-job-directly-as-context-to-builders
error.suspend.in.finally=[CANCEL_004] Llamada suspend en finally puede no completarse si se cancela. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#44-cancel_004--suspendable-cleanup-without-noncancellable
error.cancellation.swallowed=[CANCEL_003] catch(Exception) puede tragar CancellationException. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#43-cancel_003--swallowing-cancellationexception
error.cancellation.subclass=[EXCEPT_002] No est\u00e1 permitido extender CancellationException para errores de dominio. Use Exception o RuntimeException. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#52-except_002--extending-cancellationexception-for-domain-errors
error.dispatchers.unconfined=[DISPATCH_003] Debe evitarse Dispatchers.Unconfined en producci\u00f3n. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#33-dispatch_003--abusing-dispatchersunconfined
error.loop.without.yield=[CANCEL_001] Bucle en funci\u00f3n suspend sin punto de cooperaci\u00f3n. A\u00f1ada ensureActive() o yield() para permitir cancelaci\u00f3n. Ver: https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md#41-cancel_001--ignoring-cancellation-in-intensive-loops

# Tool Window - Structured Coroutines view
toolwindow.structured.coroutines=Structured Coroutines
toolwindow.stripe.StructuredCoroutines=Structured Coroutines
view.refresh=Actualizar
view.no.file.selected=Abra un archivo y pulse Actualizar para ver problemas.
view.not.kotlin.file=El archivo actual no es un archivo Kotlin.
view.no.issues=No se encontraron problemas de Structured Coroutines.
view.column.severity=Severidad
view.column.location=Ubicaci\u00f3n
view.column.inspection=Inspecci\u00f3n
view.column.message=Mensaje
view.severity.error=Error
view.severity.warning=Advertencia
