# Copyright 2026 Santiago Mattiauda
# Compiler plugin diagnostic messages (default: English).
# Use {0} for the documentation base URL (see doc.base.url).

doc.base.url=https://github.com/santimattius/structured-coroutines/blob/main/docs/BEST_PRACTICES_COROUTINES.md

UNSTRUCTURED_COROUTINE_LAUNCH=[SCOPE_003] Unstructured coroutine launch detected. Use one of the following structured alternatives:\n  \u2022 Framework scopes: viewModelScope, lifecycleScope, rememberCoroutineScope()\n  \u2022 Annotated scopes: @StructuredScope on your CoroutineScope parameter or property\n  \u2022 Structured builders: coroutineScope { }, supervisorScope { } See: {0}#13-scope_003--breaking-structured-concurrency

GLOBAL_SCOPE_USAGE=[SCOPE_001] GlobalScope usage is not allowed. GlobalScope bypasses structured concurrency and can lead to resource leaks. Use one of the following alternatives:\n  \u2022 Framework scopes: viewModelScope, lifecycleScope, rememberCoroutineScope()\n  \u2022 Annotated scopes: @StructuredScope on your CoroutineScope\n  \u2022 Structured builders: coroutineScope { }, supervisorScope { } See: {0}#11-scope_001--using-globalscope-in-production-code

INLINE_COROUTINE_SCOPE=[SCOPE_003] Inline CoroutineScope creation is not allowed. Creating CoroutineScope(Dispatchers.X).launch { } creates an orphan coroutine without lifecycle management. Use one of the following:\n  \u2022 Framework scopes: viewModelScope, lifecycleScope, rememberCoroutineScope()\n  \u2022 Annotated scopes: @StructuredScope on a properly managed CoroutineScope\n  \u2022 Structured builders: coroutineScope { }, supervisorScope { } See: {0}#13-scope_003--breaking-structured-concurrency

RUN_BLOCKING_IN_SUSPEND=[RUNBLOCK_002] runBlocking should not be called inside a suspend function. It blocks the current thread and defeats the purpose of coroutines. Use suspending alternatives or withContext instead. See: {0}#22-runblock_002--using-runblocking-inside-suspend-functions

JOB_IN_BUILDER_CONTEXT=[DISPATCH_004] Passing Job() or SupervisorJob() directly to launch/async/withContext breaks structured concurrency. The new Job becomes an independent parent, breaking the parent-child relationship. Use supervisorScope { } instead, or define a proper CoroutineScope with SupervisorJob. See: {0}#34-dispatch_004--passing-job-directly-as-context-to-builders

DISPATCHERS_UNCONFINED_USAGE=[DISPATCH_003] Dispatchers.Unconfined should be avoided in production code. It runs coroutines in whatever thread resumes them, making execution unpredictable. Use Dispatchers.Default, Dispatchers.IO, or Dispatchers.Main instead. See: {0}#33-dispatch_003--abusing-dispatchersunconfined

CANCELLATION_EXCEPTION_SUBCLASS=[EXCEPT_002] Extending CancellationException for domain errors is not allowed. CancellationException has special semantics in coroutines - it doesn't propagate like normal exceptions and only cancels the current coroutine and its children. Use a regular Exception or RuntimeException for domain errors. See: {0}#52-except_002--extending-cancellationexception-for-domain-errors

SUSPEND_IN_FINALLY_WITHOUT_NON_CANCELLABLE=[CANCEL_004] Suspend call in finally block without NonCancellable context. If the coroutine is cancelled, any suspend call will throw CancellationException and cleanup may not execute. Wrap critical cleanup in withContext(NonCancellable) { }. See: {0}#44-cancel_004--suspendable-cleanup-without-noncancellable

CANCELLATION_EXCEPTION_SWALLOWED=[CANCEL_003] catch(Exception) or catch(Throwable) may swallow CancellationException, preventing proper cancellation. Either add a separate catch(CancellationException) { throw it } clause, use ensureActive() in the catch block, or re-throw the exception. See: {0}#43-cancel_003--swallowing-cancellationexception

UNUSED_DEFERRED=[SCOPE_002] async call creates a Deferred that is never awaited. This can hide exceptions and is confusing. Either call .await() on the Deferred, use awaitAll() for multiple deferreds, or use launch() if you don't need a result. See: {0}#12-scope_002--using-async-without-calling-await

REDUNDANT_LAUNCH_IN_COROUTINE_SCOPE=[RUNBLOCK_001] coroutineScope contains only a single launch, which is redundant. If you want the function to wait for the work, execute it directly without launch. If you don't want to wait, use an explicit external scope to make it clear you're breaking structured concurrency. See: {0}#21-runblock_001--using-launch-on-the-last-line-of-coroutinescope

LOOP_WITHOUT_YIELD=[CANCEL_001] Loop in suspend function without cooperation point. The coroutine cannot be cancelled until the loop completes. Add yield(), ensureActive(), or delay() inside the loop to allow cancellation. See: {0}#41-cancel_001--ignoring-cancellation-in-intensive-loops
